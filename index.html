<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">

    <head>
        <title>Pybricks RC Car</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    </head>
    <body>
      <div class="container-fluid p-5 bg-primary text-white text-center">
        <h1>Pybricks RC Car</h1>
        <p>Click the button to connect to Pybricks!</p> 
      </div>
     <div class="text-center mt-3">
     Use your keyboard keys to move the car!
     <br>
    <div id="status"><span style="color: red;">Disconnected</span></div>
	<button type="button" class="btn btn-primary shadow" id="connect_bt">Connect</button>
	</div>
    <body class="d-flex flex-column min-vh-100">
    <footer class="bg-body-tertiary text-center text-lg-start mt-auto">
  <!-- Copyright -->
  <div class="text-center p-3 mt-auto" style="background-color: rgba(0, 0, 0, 0.05);">
    Â© 2024 Copyright:
    <a class="text-body" href="https://github.com/justaCasualCoder">JustaCasualCoder</a>
    <br>
    <a class="text-body"
    href="https://github.com/justaCasualCoder/Pybrick-RC-Car/">Source Code</a>
  </div>
  <!-- Copyright -->
</footer>
</body>
</body>
</html>
<script>
	// Define Pybricks UUID's
    let pybricks_service_uuid = 'c5f50001-8280-46da-89f4-6d8051e4aeef';
    let pybricks_event_uuid = 'c5f50002-8280-46da-89f4-6d8051e4aeef';
    // Define UTF8 Encoder/Decoder
    let b_encoder = new TextEncoder();
    let b_decoder = new TextDecoder('utf-8');
    // Define arrow keys and there corresponding commands on keypress
    let movement_cmds_keydown = {
        'ArrowUp': b_encoder.encode('fwd'), // Forward
        'ArrowDown': b_encoder.encode('rev'), // Reverse
        'ArrowLeft': b_encoder.encode('lfe'), // Left
        'ArrowRight': b_encoder.encode('rig'), // Right
    };
    // Define arrow keys and there corresponding commands on key release
    let movement_cmds_keyup = {
        'ArrowUp': b_encoder.encode('stp'), // Stop
        'ArrowDown': b_encoder.encode('stp'), // Stop
        'ArrowLeft': b_encoder.encode('mid'), // Center turning
        'ArrowRight': b_encoder.encode('mid'), // Center turning
    };
    // Define Bluetooth Characteristic
    let bluetooth_char;
    // Don't send commands until program is started
    let ready = 0;
    // No key has been pressed yet
    let latest_cmd = "";
    // Status element
    let status_element = document.getElementById("status");
    // Define command queue
    let cmd_queue = Promise.resolve();
    document.getElementById('connect_bt').addEventListener('click', async () => {
    try {
    // Request Bluetooth devices with Pybricks service filter
    let device = await navigator.bluetooth.requestDevice({
    	filters: [{ services: [pybricks_service_uuid] }],
       });
    // Connect to device with GATT
    let gatt_srv = await device.gatt.connect();
    // Create service handle
    let service_handle = await gatt_srv.getPrimaryService(pybricks_service_uuid);
    // Get Bluetooth characteristic
    bluetooth_char = await service_handle.getCharacteristic(pybricks_event_uuid);
    // Handle Bluetooth RX
    bluetooth_char.addEventListener('characteristicvaluechanged', (event) => handle_rx(event))
    await bluetooth_char.startNotifications();
    status_element.innerHTML = "<span style='color: blue;'>Start the program on the Hub</span>";
    // Handle keypresses
    document.addEventListener('keydown', handleKeyPress);
    document.addEventListener('keyup', handleKeyPress);
    } catch (error) {
        console.error("Error connecting to Pybricks Hub:", error);
    }
    // Create RX Handling function
    function handle_rx(event) {
        let decoded_string = b_decoder.decode(event.target.value.buffer);
        if (ready != 1) {
            if (decoded_string.includes('rdy')) {
                ready = 1
                console.log('Hub Ready')
                status_element.innerHTML = "<span style='color: green;'>Hub Ready!</span>";
        }
        }
    }
    async function send_cmd_pybricks(message) {
        // Wrap the command in a function to be called later in the promise chain
        const sendCommand = async () => {
            // For testing purposes, log the command to the console
            await bluetooth_char.writeValue(message);
        };
        // Add command to promise chain
        cmd_queue = cmd_queue.then(sendCommand).catch(error => {
            console.error(`Error sending command: ${message}`, error);
        });
        // Return promise
        return cmd_queue;
    }
    function handleKeyPress(event) {
        let key = event.key;
        if (ready) {
            // If key is not being held
            if (latest_cmd != key) {
                // If it is a keypress and it is a recognized key
                if (event.type === 'keydown' && movement_cmds_keydown[key]) {
                    latest_cmd = key
                    // Define temporary variable
                    let temp_message = movement_cmds_keydown[key];
                    // Add 6 to command (6 is the Pybricks code for write to stdin)
                    let message = new Uint8Array([6, ...temp_message]);
                    // Call Pybricks command sender
                    send_cmd_pybricks(message);
                }
            }
        }
        // if it is a key being released
        if (event.type === 'keyup' && movement_cmds_keyup[key]) {
            latest_cmd = ""
            let temp_message = movement_cmds_keyup[key];
            // Add 6 to command (6 is the Pybricks code for write to stdin)
            let message = new Uint8Array([6, ...temp_message]);
            send_cmd_pybricks(message);
        }
    }

});
</script>
